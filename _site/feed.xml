<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>M-x doctor RET</title>
    <description>Everybody needs a good Emacs doctor.</description>
    <link>https://emacs-doctor.com/</link>
    <atom:link href="https://emacs-doctor.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 11 Mar 2019 16:27:34 +0100</pubDate>
    <lastBuildDate>Mon, 11 Mar 2019 16:27:34 +0100</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Notes from an Org-mode demonstration</title>
        <description>
&lt;p&gt;Thanks to the &lt;a href=&quot;https://www.medialab-prado.es/&quot;&gt;MediaLab Prado&lt;/a&gt; and &lt;a href=&quot;http://twitter.com/adolflow&quot;&gt;Adolfo Antón Bravo&lt;/a&gt; for inviting me to
  make a small demonstration of org-mode.&lt;/p&gt;
&lt;p&gt;Here are the notes I used during the demo.&lt;/p&gt;
&lt;h1&gt;GNU Emacs&lt;/h1&gt;
&lt;p&gt;There use to be an editor war between Emacs and Vi(m).&lt;/p&gt;
&lt;p&gt;This is now history, Emacs won thanks to &lt;a href=&quot;https://orgmode.org&quot;&gt;org-mode&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Org-mode: key ideas&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;You need a single tool for both notes and tasks.&lt;/li&gt;
  &lt;li&gt;Your TODO list application should not be too rigid.  Ideally, it is
    a pedagogical tool, one that helps to be &lt;i&gt;slightly&lt;/i&gt; better organized.&lt;/li&gt;
  &lt;li&gt;org-mode is both a &lt;i&gt;format&lt;/i&gt; a la markdown and a &lt;i&gt;set of tools&lt;/i&gt; around
    this format.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Org-mode history&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;2003 : Carsten Dominik starts writing org-mode as a usable
    outline-mode&lt;/li&gt;
  &lt;li&gt;2011 : Bastien becomes org-mode the maintainer&lt;/li&gt;
  &lt;li&gt;2014 : Nicolas Goaziou becomes the main developer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;More closely integrate with Emacs ?&lt;/li&gt;
  &lt;li&gt;More parsers and exporters outside Emacs ?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Notes on org-mode development&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;We don’t have a roadmap: user driven development.&lt;/li&gt;
  &lt;li&gt;We don’t have a bug tracker: see the o&lt;a href=&quot;https://www.konmari.com/&quot;&gt;KonMari&lt;/a&gt; methodology: discard
    beforing storing.&lt;/li&gt;
  &lt;li&gt;We don’t have a business model.&lt;/li&gt;
  &lt;li&gt;We DO have a strong culture of &lt;b&gt;being nice&lt;/b&gt; to newcomers.&lt;/li&gt;
  &lt;li&gt;We DO have a strong culture of &lt;b&gt;not breaking things&lt;/b&gt;.&lt;/li&gt;
  &lt;li&gt;We started Worg as a git-based community-driven documentation.&lt;/li&gt;
  &lt;li&gt;We plan to write our documentation in .org &lt;code&gt;\o/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Org-mode as structured text editing&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Headlines&lt;/li&gt;
  &lt;li&gt;Tags&lt;/li&gt;
  &lt;li&gt;TODO keywords&lt;/li&gt;
  &lt;li&gt;Properties&lt;/li&gt;
  &lt;li&gt;Lists&lt;/li&gt;
  &lt;li&gt;Tables&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Org-mode as a spreadsheet&lt;/h1&gt;
&lt;p&gt;Let’s build a table!&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;A&lt;/th&gt;&lt;th&gt;Poetry&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Nick&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Bastien&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Élodie&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;pre class=&quot;example&quot;&gt;
M-x org-table-import RET ~/test.csv
&lt;/pre&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;h1&gt;Org-mode exporter&lt;/h1&gt;
&lt;pre class=&quot;example&quot;&gt;
M-x org-export-dispatch RET
&lt;/pre&gt;
&lt;h1&gt;Org-mode for literate programming&lt;/h1&gt;
&lt;p&gt;Here are some explanations about &lt;code&gt;a-function&lt;/code&gt;.  Then here is the
  function:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(defun a-function ()
  (interactive)
  (message &amp;quot;Hello!&amp;quot;))
&lt;/pre&gt;
&lt;p&gt;Now, pressing &lt;code&gt;C-c C-v t&lt;/code&gt; I will &amp;#8220;tangle&amp;#8221; these chunks of code in a
  single file.&lt;/p&gt;
&lt;h1&gt;Org-mode as a TODO list manager&lt;/h1&gt;
&lt;pre class=&quot;example&quot;&gt;
M-x org-todo RET
&lt;/pre&gt;
&lt;h1&gt;Org &amp;#8220;agenda&amp;#8221; views&lt;/h1&gt;
&lt;pre class=&quot;example&quot;&gt;
M-x org-agenda RET
&lt;/pre&gt;
&lt;h1&gt;Capturing items&lt;/h1&gt;
&lt;pre class=&quot;example&quot;&gt;
M-x org-capture RET
&lt;/pre&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Come and play!&lt;/li&gt;
&lt;/ul&gt;


</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/org-mode-demo-notes.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/org-mode-demo-notes.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Bloguer avec Emacs, Org-mode, Git et Jekyll</title>
        <description>
&lt;video style=&quot;width:100%;margin:auto;&quot; controls autoplay&gt;
  &lt;source src=&quot;/img/bloguer_depuis_emacs.ogv&quot; type=&quot;video/ogg&quot;&gt;
&lt;/video&gt;


</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 +0200</pubDate>
        <link>https://emacs-doctor.com/blog-avec-emacs-orgmode-git-jekyll.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/blog-avec-emacs-orgmode-git-jekyll.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Tutorial introduction to searching in Emacs</title>
        <description>
&lt;p&gt;Go to the main Info buffer with &lt;code&gt;C-h i&lt;/code&gt;.  Hit &lt;code&gt;d&lt;/code&gt; to make sure you are
  at the top-level of the Info documentation, and go at the beginning of
  the buffer with &lt;code&gt;M-&amp;lt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Perform an incremental search for &amp;#8220;lisp&amp;#8221; with &lt;code&gt;C-s lisp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/2016-11-07-emacs-search-lisp.png&quot; alt=&quot;img/2016-11-07-emacs-search-lisp.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;RET&lt;/code&gt; to deactivate the search and the highlighting of search
  matches.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-r&lt;/code&gt; to search backwards.&lt;/p&gt;
&lt;p&gt;Now hit &lt;code&gt;C-s C-s&lt;/code&gt; to search for the last search string again.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;M-e&lt;/code&gt; to edit the search string.  Delete &amp;#8220;lisp&amp;#8221; in the minibuffer
  prompt, type &amp;#8220;mode&amp;#8221; and &lt;code&gt;RET&lt;/code&gt; to reenter the search loop.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/2016-11-07-emacs-search-mode.png&quot; alt=&quot;img/2016-11-07-emacs-search-mode.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;M-p&lt;/code&gt;.  Your cursor will be back in the minibuffer prompt and you
  can hit &lt;code&gt;M-p&lt;/code&gt; and &lt;code&gt;M-n&lt;/code&gt; to cycle through previous search strings, and &lt;code&gt;RET&lt;/code&gt;
  to search the selected string again.&lt;/p&gt;
&lt;p&gt;Go back to the beginning of the Info buffer with &lt;code&gt;M-&amp;lt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s&lt;/code&gt; to start the search.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-q C-j&lt;/code&gt; to search for the newline character.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C-q&lt;/code&gt; is used to insert &lt;code&gt;C-j&lt;/code&gt; and &lt;code&gt;RET&lt;/code&gt; literally: if you don&amp;#8217;t use &lt;code&gt;C-q&lt;/code&gt;,
  typing &lt;code&gt;C-j&lt;/code&gt; and &lt;code&gt;RET&lt;/code&gt; in the search prompt will exit the prompt.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-g&lt;/code&gt; to abort the search.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s&lt;/code&gt; and search for &lt;code&gt;mail&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Notice that both &amp;#8220;Mail&amp;#8221; and &amp;#8220;mail&amp;#8221; will be matched: the search is not
  case sensitive.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-u C-SPC&lt;/code&gt; to go back to your position before your search.&lt;/p&gt;
&lt;p&gt;While in the search loop, hit &lt;code&gt;M-c&lt;/code&gt; (or &lt;code&gt;M-s c&lt;/code&gt;) to toggle case
  sensitivity: you will notice that now only &amp;#8220;mail&amp;#8221; is highlighted.&lt;/p&gt;
&lt;p&gt;While in the search loop, hit &lt;code&gt;M-s SPC&lt;/code&gt; to toggle &amp;#8220;match spaces
  loosely&amp;#8221;: when matching spaces loosely, you can search for a string
  like &amp;#8220;mail   client&amp;#8221; (with three hard spaces) and still match the
  &amp;#8220;mail client&amp;#8221; string.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/2016-11-07-emacs-search-loosely.png&quot; alt=&quot;img/2016-11-07-emacs-search-loosely.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Still in the search loop, &lt;code&gt;M-s w&lt;/code&gt; will perform word-based searches.  For
  example, word-based search for &amp;#8220;mail&amp;#8221; will not match &amp;#8220;email&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Now try searching for &lt;code&gt;maii&lt;/code&gt; instead of &lt;code&gt;mail&lt;/code&gt; and then hit &lt;code&gt;DEL&lt;/code&gt; to
  edit the search string by deleting the last character.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s&lt;/code&gt; and search again for &amp;#8220;mail&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;RET&lt;/code&gt; on the first occurrence and go one word backward with &lt;code&gt;M-b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now hit &lt;code&gt;C-s C-w&lt;/code&gt; to search for the word at point (it should be &amp;#8220;mail&amp;#8221;).&lt;/p&gt;
&lt;p&gt;Try again with &lt;code&gt;C-s C-w C-w&lt;/code&gt; to search for several words at point.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s C-M-y&lt;/code&gt; to search for the character at point.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-M-y C-M-y&lt;/code&gt; to add the next two characters to the search string.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-M-w&lt;/code&gt; to remove the last character from the search string.&lt;/p&gt;
&lt;p&gt;Exit the search with &lt;code&gt;C-g&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Info buffers are read-only by default: hit &lt;code&gt;M-d&lt;/code&gt; on a word to copy it.
  In normal buffers, you would use &lt;code&gt;C-M-SPC&lt;/code&gt; to mark the &amp;#8220;sexp&amp;#8221; under
  cursor (here, the &amp;#8220;sexp&amp;#8221; is simply a word), then &lt;code&gt;M-w&lt;/code&gt; to copy it
  (i.e. to &amp;#8220;add it to the kill-ring).&lt;/p&gt;
&lt;p&gt;Now hit &lt;code&gt;C-s&lt;/code&gt; again, then &lt;code&gt;C-y&lt;/code&gt; to paste (i.e. &amp;#8220;yank&amp;#8221;) the text in the
  search area.&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s C-M-i&lt;/code&gt;.  This will displays a new window with a list of
  possible completions for the current search string.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/2016-11-07-emacs-search-completion.png&quot; alt=&quot;img/2016-11-07-emacs-search-completion.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;M-&amp;lt;&lt;/code&gt; and &lt;code&gt;C-s&lt;/code&gt; to search for &amp;#8220;mail&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Now hit &lt;code&gt;M-s o&lt;/code&gt; to list lines where &amp;#8220;mail&amp;#8221; occurs.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/2016-11-07-emacs-search-occur.png&quot; alt=&quot;img/2016-11-07-emacs-search-occur.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hit &lt;code&gt;C-s&lt;/code&gt; and &lt;code&gt;M-r&lt;/code&gt; (or &lt;code&gt;M-s r&lt;/code&gt;) to switch to regular expression search.&lt;/p&gt;
&lt;p&gt;Go to an org-mode buffer.  Hit &lt;code&gt;M-TAB&lt;/code&gt; to cycle through visibility
  status and stop when in the &lt;code&gt;OVERVIEW&lt;/code&gt; mode (everything is folded).&lt;/p&gt;
&lt;p&gt;Search for hidden text: the matched string is automatically unfolded
  when the cursor moves to it.&lt;/p&gt;
&lt;p&gt;Exit the search.&lt;/p&gt;
&lt;p&gt;Still in this org-mode buffer, hit &lt;code&gt;M-TAB&lt;/code&gt; to fold the subtrees and hit
  &lt;code&gt;C-s M-s i&lt;/code&gt; to search for visible text only.  Invisible text won&amp;#8217;t be
  matched.&lt;/p&gt;
&lt;p&gt;In any buffer, hit &lt;code&gt;C-s C-h b&lt;/code&gt; to browse the search options.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Things I wish I knew sooner:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;C-s M-e&lt;/code&gt; to edit the search string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-s M-w&lt;/code&gt; to search for word at point&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-s M-r&lt;/code&gt; to toggle search by regular expressions&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-s M-s o&lt;/code&gt; to run &lt;code&gt;occur&lt;/code&gt; on the current search string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-s C-M-i&lt;/code&gt; to complete the current search string&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-s a-test-string M-x&lt;/code&gt; to replace the matched string in the buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Enjoy, and check the &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html&quot;&gt;Emacs manual&lt;/a&gt; for more.&lt;/p&gt;
&lt;p&gt;And you, what are your Emacs search &amp;#8220;ahah!&amp;#8221; moment?&lt;/p&gt;
&lt;p&gt;Thank &lt;a href=&quot;https://www.reddit.com/r/emacs/comments/5bkp0g/tutorial_introduction_to_searching_in_emacs/d9pdd0x/&quot;&gt;martijntje&lt;/a&gt; for his suggestions.&lt;/p&gt;


</description>
        <pubDate>Mon, 07 Nov 2016 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/tutorial-introduction-searching-emacs.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/tutorial-introduction-searching-emacs.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Emacs, naked.</title>
        <description>
&lt;blockquote&gt;
  &lt;p&gt;When it gets too cold, you can always put on more layers of
    clothing. But when it gets too hot, after a while you can&amp;#8217;t
    take off any more. &amp;#8211; RMS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is GNU Emacs:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/bare-emacs.png&quot; alt=&quot;img/bare-emacs.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now let the show begin&amp;#8230;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Code snippets are for GNU Emacs 24.3 and above.&lt;/i&gt;&lt;/p&gt;
&lt;h2&gt;A blank stage&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Prevent the cursor from blinking
(blink-cursor-mode 0)
;; Don&amp;#39;t use messages that you don&amp;#39;t read
(setq initial-scratch-message &amp;quot;&amp;quot;)
(setq inhibit-startup-message t)
;; Don&amp;#39;t let Emacs hurt your ears
(setq visible-bell t)

;; You need to set `inhibit-startup-echo-area-message&amp;#39; from the
;; customization interface:
;; M-x customize-variable RET inhibit-startup-echo-area-message RET
;; then enter your username
(setq inhibit-startup-echo-area-message &amp;quot;guerry&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-blank-stage.png&quot; alt=&quot;img/emacs-blank-stage.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Break the walls&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; This is bound to f11 in Emacs 24.4
(toggle-frame-fullscreen) 
;; Who use the bar to scroll?
(scroll-bar-mode 0)
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-fullscreen.png&quot; alt=&quot;img/emacs-fullscreen.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;The sky is the limit&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(tool-bar-mode 0)
(menu-bar-mode 0)

;; You can also set the initial frame parameters
;; (setq initial-frame-alist
;;       &amp;#39;((menu-bar-lines . 0)
;;         (tool-bar-lines . 0)))
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-clear-top.png&quot; alt=&quot;img/emacs-clear-top.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Groundless fear&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; See http://bzg.fr/emacs-hide-mode-line.html
(defvar-local hidden-mode-line-mode nil)
(defvar-local hide-mode-line nil)

(define-minor-mode hidden-mode-line-mode
  &amp;quot;Minor mode to hide the mode-line in the current buffer.&amp;quot;
  :init-value nil
  :global nil
  :variable hidden-mode-line-mode
  :group &amp;#39;editing-basics
  (if hidden-mode-line-mode
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  ;; Apparently force-mode-line-update is not always enough to
  ;; redisplay the mode-line
  (redraw-display)
  (when (and (called-interactively-p &amp;#39;interactive)
             hidden-mode-line-mode)
    (run-with-idle-timer
     0 nil &amp;#39;message
     (concat &amp;quot;Hidden Mode Line Mode enabled.  &amp;quot;
             &amp;quot;Use M-x hidden-mode-line-mode to make the mode-line appear.&amp;quot;))))

;; Activate hidden-mode-line-mode
(hidden-mode-line-mode 1)

;; If you want to hide the mode-line in all new buffers
;; (add-hook &amp;#39;after-change-major-mode-hook &amp;#39;hidden-mode-line-mode)

;; Alternatively, you can paint your mode-line in White but then
;; you&amp;#39;ll have to manually paint it in black again
;; (custom-set-faces
;;  &amp;#39;(mode-line-highlight ((t nil)))
;;  &amp;#39;(mode-line ((t (:foreground &amp;quot;white&amp;quot; :background &amp;quot;white&amp;quot;))))
;;  &amp;#39;(mode-line-inactive ((t (:background &amp;quot;white&amp;quot; :foreground &amp;quot;white&amp;quot;)))))
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-clear-bottom.png&quot; alt=&quot;img/emacs-clear-bottom.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Well&amp;#8230; it&amp;#8217;s more interesting with some text:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-clear-bottom-text.png&quot; alt=&quot;img/emacs-clear-bottom-text.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;In the limelight&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; A small minor mode to use a big fringe
(defvar bzg-big-fringe-mode nil)
(define-minor-mode bzg-big-fringe-mode
  &amp;quot;Minor mode to use big fringe in the current buffer.&amp;quot;
  :init-value nil
  :global t
  :variable bzg-big-fringe-mode
  :group &amp;#39;editing-basics
  (if (not bzg-big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
           (* 100 (frame-char-width)))
        2))))

;; Now activate this global minor mode
(bzg-big-fringe-mode 1)

;; To activate the fringe by default and deactivate it when windows
;; are split vertically, uncomment this:
;; (add-hook &amp;#39;window-configuration-change-hook
;;           (lambda ()
;;             (if (delq nil
;;                       (let ((fw (frame-width)))
;;                         (mapcar (lambda(w) (&amp;lt; (window-width w) (/ fw 2)))
;;                                 (window-list))))
;;                 (bzg-big-fringe-mode 0)
;;               (bzg-big-fringe-mode 1))))

;; Use a minimal cursor
;; (setq default-cursor-type &amp;#39;hbar)

;; Get rid of the indicators in the fringe
(mapcar (lambda(fb) (set-fringe-bitmap-face fb &amp;#39;org-hide))
        fringe-bitmaps)
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-big-fringe.png&quot; alt=&quot;img/emacs-big-fringe.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Oh, but you don&amp;#8217;t want the grey fringe?&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Set the color of the fringe
(custom-set-faces
 &amp;#39;(fringe ((t (:background &amp;quot;white&amp;quot;)))))
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-big-white-fringe.png&quot; alt=&quot;img/emacs-big-white-fringe.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Let&amp;#8217;s turn off the light&amp;#8230;&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(custom-set-faces
  &amp;#39;(default ((t (:background &amp;quot;black&amp;quot; :foreground &amp;quot;grey&amp;quot;))))
  &amp;#39;(fringe ((t (:background &amp;quot;black&amp;quot;)))))
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-by-night.png&quot; alt=&quot;img/emacs-by-night.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Enjoy !&lt;/h2&gt;
&lt;p&gt;(Keep the sound muted.)&lt;/p&gt;
 &lt;center&gt;
 &lt;video style=&quot;width:100%;margin:auto;&quot; controls muted&gt;
   &lt;source src=&quot;img/emacs-strip.ogv&quot; type=&quot;video/ogg&quot;&gt;
 &lt;/video&gt;
 &lt;/center&gt;
&lt;p&gt;Download the video &lt;a href=&quot;img/emacs-strip.ogv&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Download the full Elisp file &lt;a href=&quot;img/emacs-strip.el&quot;&gt;here&lt;/a&gt; or read it as a &lt;a href=&quot;https://gist.github.com/bzg/8578998&quot;&gt;gist&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Bonus trick&lt;/h2&gt;
&lt;p&gt;Ok, sometimes I &lt;b&gt;still&lt;/b&gt; want to see what&amp;#8217;s in the mode-line.&lt;/p&gt;
&lt;p&gt;I use the &lt;code&gt;C-s-SPC&lt;/code&gt; key for this (Control Super Space) with
  this simple function to display the mode-line in the header:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Command to toggle the display of the mode-line as a header
(defvar-local header-line-format nil)
(defun mode-line-in-header ()
  (interactive)
  (if (not header-line-format)
      (setq header-line-format mode-line-format
            mode-line-format nil)
    (setq mode-line-format header-line-format
          header-line-format nil))
  (set-window-buffer nil (current-buffer)))
(global-set-key (kbd &amp;quot;C-s-SPC&amp;quot;) &amp;#39;mode-line-in-header)
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-mode-line-header.png&quot; alt=&quot;img/emacs-mode-line-header.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Discussed on HN: &lt;a href=&quot;https://news.ycombinator.com/item?id=7107893&quot;&gt;https://news.ycombinator.com/item?id=7107893&lt;/a&gt;&lt;/p&gt;


</description>
        <pubDate>Wed, 22 Jan 2014 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/emacs-strip-tease.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/emacs-strip-tease.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Emacs mode for hiding the mode-line</title>
        <description>
&lt;p&gt;Sometimes I don&amp;#8217;t want to display the &lt;code&gt;mode-line&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This minor mode helps me switching it on and off:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(defvar-local hidden-mode-line-mode nil)

(define-minor-mode hidden-mode-line-mode
  &amp;quot;Minor mode to hide the mode-line in the current buffer.&amp;quot;
  :init-value nil
  :global t
  :variable hidden-mode-line-mode
  :group &amp;#39;editing-basics
  (if hidden-mode-line-mode
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  ;; Apparently force-mode-line-update is not always enough to
  ;; redisplay the mode-line
  (redraw-display)
  (when (and (called-interactively-p &amp;#39;interactive)
             hidden-mode-line-mode)
    (run-with-idle-timer
     0 nil &amp;#39;message
     (concat &amp;quot;Hidden Mode Line Mode enabled.  &amp;quot;
             &amp;quot;Use M-x hidden-mode-line-mode to make the mode-line appear.&amp;quot;))))

;; If you want to hide the mode-line in every buffer by default
;; (add-hook &amp;#39;after-change-major-mode-hook &amp;#39;hidden-mode-line-mode)
&lt;/pre&gt;
&lt;p&gt;Just use &lt;code&gt;M-x hidden-mode-line-mode RET&lt;/code&gt; and you&amp;#8217;re done.&lt;/p&gt;


</description>
        <pubDate>Fri, 17 Jan 2014 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/emacs-hide-mode-line.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/emacs-hide-mode-line.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>How To Exit Emacs?</title>
        <description>
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;Spending the rest of your life in Emacs is a feature, not a bug.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/i3.png&quot; alt=&quot;img/i3.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;tl;dr (take 2)&lt;/h2&gt;
&lt;p&gt;This is the magic key combination to exit Emacs:&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
C-x C-c
&lt;/pre&gt;
&lt;p&gt;Which reads as&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
Control-x Control-c
&lt;/pre&gt;
&lt;h2&gt;&amp;#8211;help&lt;/h2&gt;
&lt;p&gt;I.e., press the &lt;code&gt;Control&lt;/code&gt; key with your left pinky, hold it pressed,
  then press &lt;code&gt;x&lt;/code&gt;, release &lt;code&gt;x&lt;/code&gt; (while still holding the &lt;code&gt;Control&lt;/code&gt; key),
  press &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ta-da!&lt;/p&gt;
&lt;p&gt;You are back to normal life.&lt;/p&gt;
&lt;h2&gt;&amp;#8211;help &amp;#8211;verbose&lt;/h2&gt;
&lt;p&gt;In Emacs, key bindings are called &lt;code&gt;keybindings&lt;/code&gt;, because we like
  things to be plain.  Some people in other possible worlds called them
  &lt;code&gt;shortcuts&lt;/code&gt;, but that&amp;#8217;s a very narrow view of what a keybinding is,
  since Emacs keybindings have a personnality of their own, and can be a
  bit long sometimes.&lt;/p&gt;
&lt;p&gt;The first time you encounter &lt;code&gt;Control-x&lt;/code&gt;, you think: &amp;#8220;Aha&amp;#8230; so the
  &lt;code&gt;x&lt;/code&gt; stands for eXiting!&amp;#8221;.  Wrong.&lt;/p&gt;
&lt;p&gt;The &amp;#8220;x&amp;#8221; stands for eXecuting.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s tell a bit more about keybindings.&lt;/p&gt;
&lt;h2&gt;&amp;#8211;help &amp;#8211;very-verbose&lt;/h2&gt;
&lt;p&gt;Emacs keybindings are stored in &lt;code&gt;keymaps&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;keymap&lt;/code&gt; is a variable containing a list of associations between
  keys and &lt;code&gt;commands&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The list of all keybindings starting with &lt;code&gt;Control-x&lt;/code&gt; is stored in a
  dedicated variable called &lt;code&gt;ctl-x-map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can see this list with &lt;code&gt;C-h v ctl-x-map RET&lt;/code&gt;: this will open a new
  buffer and display the value of the keymap.&lt;/p&gt;
&lt;p&gt;You can also display the list of commands starting with the &lt;code&gt;C-x&lt;/code&gt;
  prefix bit hitting &lt;code&gt;C-x C-h&lt;/code&gt; (yes, the &lt;code&gt;h&lt;/code&gt; stands for help).&lt;/p&gt;
&lt;p&gt;Do it &lt;i&gt;now&lt;/i&gt;, and enjoy the beautiful view!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/emacs-keybindings.png&quot; alt=&quot;img/emacs-keybindings.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In this buffer, you can follow links by hitting &lt;code&gt;RET&lt;/code&gt; (aka &lt;code&gt;return&lt;/code&gt;):
  those are links to the descriptions of commands associated with the
  listed keybindings&amp;#8212;or to &lt;i&gt;sub keymaps&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;For example, the buffer will let you learn that &lt;code&gt;C-x C-c&lt;/code&gt; is bound to
  &lt;code&gt;save-buffers-kill-terminal&lt;/code&gt;.  Yes, this is the name of the command
  you call to &amp;#8220;exit Emacs&amp;#8221;, as people call it sometimes.&lt;/p&gt;
&lt;p&gt;But &lt;code&gt;C-x C-k&lt;/code&gt; is bound to &lt;code&gt;kmacro-keymap&lt;/code&gt;, which is not a command, but
  another map.&lt;/p&gt;
&lt;p&gt;If you want to know more about this other keymap, hit &lt;code&gt;C-x C-k C-h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(And yes, the &amp;#8220;h&amp;#8221; in &lt;code&gt;C-h&lt;/code&gt; stands for Help.)&lt;/p&gt;
&lt;p&gt;Of course, since keymaps are just variables, you can change them at
  will.  I recommend not to change the default keybindings: Emacs is not
  only a text editor, it&amp;#8217;s a shared culture, and sticking to the default
  keybindings helps the community celebrate the same commands together.&lt;/p&gt;
&lt;h2&gt;x = ?&lt;/h2&gt;
&lt;pre class=&quot;example&quot;&gt;
Happiness is nothing more than good health and a bad memory.

                            -- Albert Schweitzer
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Control-x&lt;/code&gt; keymap is the most important keymap in Emacs: main
  commands are called from this keymap.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Control-c&lt;/code&gt; keymap is the second most important one.  Emacs modes
  use it to associate keybindings with the new commands they define.&lt;/p&gt;
&lt;p&gt;When reading &lt;code&gt;.emacs.el&lt;/code&gt; file late at night, amont binary dreams and
  computer fairies, you sometimes encounter a pattern: &lt;code&gt;C-c x&lt;/code&gt;, where
  &lt;code&gt;x&lt;/code&gt; is a letter or a digit.  This pattern is reserved for the user:
  this is where you, the user, are required to place your keybindings.
  No decent Emacs mode will ever use this pattern for its keybindings.&lt;/p&gt;
&lt;p&gt;Of course &lt;code&gt;C-c C-...&lt;/code&gt; is used by all modes: but this is &lt;code&gt;C-c C-...&lt;/code&gt;,
  not &lt;code&gt;C-c ...&lt;/code&gt; &amp;#8212; please note the difference.&lt;/p&gt;
&lt;p&gt;So what does this &lt;code&gt;x&lt;/code&gt; stand for?&lt;/p&gt;
&lt;p&gt;If you know Emacs, you know a bit of &lt;code&gt;M-x&lt;/code&gt;: hitting this puts the
  cursor in the &lt;code&gt;minibuffer&lt;/code&gt;, and prompts you for the name of a command.&lt;/p&gt;
&lt;p&gt;The name of the command associated with &lt;code&gt;M-x&lt;/code&gt; is
  &lt;code&gt;execute-extended-command&lt;/code&gt;, so my guess is that &lt;code&gt;x&lt;/code&gt; stands for
  &amp;#8220;execute&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Which makes sense, right?&lt;/p&gt;
&lt;p&gt;I also guess the &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;Control-x&lt;/code&gt; stands for &amp;#8220;execute&amp;#8221;, since this
  is the main map to &lt;i&gt;execute&lt;/i&gt; stuff in Emacs.  At least I want to
  believe so.&lt;/p&gt;
&lt;p&gt;What does &lt;code&gt;C-c&lt;/code&gt; stands for in &lt;code&gt;C-x C-c&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If you use &lt;code&gt;C-c&lt;/code&gt; in shells, you know the answer.  And of course
  &lt;a href=&quot;http://en.wikipedia.org/wiki/Control-C&quot;&gt;Wikipedia&lt;/a&gt; comes to the rescue:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;As many keyboards and computer terminals once directly generated ASCII
    code, the choice of control-C overlapped with the ASCII end-of-text
    character. This character has a numerical value of three, as &amp;#8220;C&amp;#8221; is
    the third letter of the alphabet. It was chosen to cause an interrupt
    as it is otherwise unlikely to be part of a program&amp;#8217;s interactive
    interface. Many other control codes, such as control-D for the
    end-of-transmission character, do not generate signals and are
    occasionally used to control a program.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;See?  Now you know why &lt;code&gt;C-x C-c&lt;/code&gt; exits Emacs.&lt;/p&gt;
&lt;p&gt;But remember: you don&amp;#8217;t really want to exit Emacs (see &lt;a href=&quot;*tl%3Bdr&quot;&gt;tl;dr&lt;/a&gt;).&lt;/p&gt;


</description>
        <pubDate>Mon, 23 Dec 2013 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/how-to-exit-emacs.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/how-to-exit-emacs.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Emacs Org and Overtone quick intro</title>
        <description>
&lt;p&gt;This file will take you through installing &lt;a href=&quot;http://www.gnu.org/software/emacs/&quot;&gt;GNU Emacs&lt;/a&gt; and &lt;a href=&quot;http://overtone.github.io/&quot;&gt;Overtone&lt;/a&gt; so
  that you can play a few notes.&lt;/p&gt;
&lt;p&gt;You want to read it within GNU Emacs and &lt;a href=&quot;http://orgmode.org/&quot;&gt;Org-mode&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Installation&lt;/h2&gt;
&lt;h3&gt;Install GNU Emacs&lt;/h3&gt;
&lt;p&gt;If you are using Debian, &lt;code&gt;~$ apt-get install emacs&lt;/code&gt; will do.&lt;/p&gt;
&lt;p&gt;To install Emacs from sources, you can download it from &lt;a href=&quot;ftp://ftp.gnu.org/pub/gnu/emacs/&quot;&gt;here&lt;/a&gt; or clone
  the git mirror:&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
~$ git clone git://git.savannah.gnu.org/emacs.git
&lt;/pre&gt;
&lt;h3&gt;Configure Emacs&lt;/h3&gt;
&lt;p&gt;The beginning of your Emacs configuration should contain this to add
  &lt;code&gt;marmelade&lt;/code&gt; to the list of known repositories for Emacs libraries:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(require &amp;#39;package)
(add-to-list &amp;#39;package-archives
             &amp;#39;(&amp;quot;marmalade&amp;quot; . &amp;quot;http://marmalade-repo.org/packages/&amp;quot;))
(package-initialize)
&lt;/pre&gt;
&lt;p&gt;Now hit &lt;code&gt;C-c C-v C-t&lt;/code&gt; to &lt;i&gt;tangle&lt;/i&gt; all Emacs Lisp code blocks from this
  file into a new &lt;code&gt;emacs.el&lt;/code&gt; file in the same directory.&lt;/p&gt;
&lt;p&gt;When done, go check this new &lt;code&gt;emacs.el&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can use this &lt;code&gt;emacs.el&lt;/code&gt; to load the minimal configuration needed
  for this tutorial.&lt;/p&gt;
&lt;h3&gt;Install Cider (was &amp;#8220;nrepl.el&amp;#8221;)&lt;/h3&gt;
&lt;p&gt;Now run Emacs like this:&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
~$ emacs -l /path/to/overtone-intro/emacs.el
&lt;/pre&gt;
&lt;p&gt;In Emacs, get the list of packages:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M-x list-packages RET&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and install &lt;code&gt;cider&lt;/code&gt; from that list.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: This will also install &lt;code&gt;clojure-mode-2.0.0&lt;/code&gt;, &lt;code&gt;cl-lib-0.3&lt;/code&gt;,
  &lt;code&gt;dash-2.1.0&lt;/code&gt; and &lt;code&gt;pkg-info-0.3&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Install Org-mode&lt;/h3&gt;
&lt;p&gt;Install the latest version of &lt;a href=&quot;http://orgmode.org/&quot;&gt;Org-mode&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
~$ git clone git://orgmode.org/org-mode.git
~$ cd org-mode
~$ make autoloads
&lt;/pre&gt;
&lt;p&gt;This will compile Emacs Lisp files in the &lt;code&gt;org-mode/lisp/&lt;/code&gt; directory
  and create &lt;code&gt;org-loaddefs.el&lt;/code&gt;, containing the necessary autoloads.&lt;/p&gt;
&lt;h3&gt;Configure Org-mode&lt;/h3&gt;
&lt;p&gt;This simple Org configuration should do:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(add-to-list &amp;#39;load-path &amp;quot;~/install/git/org-mode/&amp;quot;)
(require &amp;#39;org)

;; We only need Emacs Lisp and Clojure in this tutorial:
(org-babel-do-load-languages
 &amp;#39;org-babel-load-languages
 &amp;#39;((emacs-lisp . t)
   (clojure . t)))

;; Use cider as the clojure execution backend
(setq org-babel-clojure-backend &amp;#39;cider)

;; Let&amp;#39;s have pretty source code blocks
(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-fontify-natively t
      org-confirm-babel-evaluate nil)
&lt;/pre&gt;
&lt;h3&gt;Configure cider&lt;/h3&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Cider configuration
(require &amp;#39;cider)
(setq nrepl-hide-special-buffers t
      cider-repl-pop-to-buffer-on-connect nil
      cider-popup-stacktraces nil
      cider-repl-popup-stacktraces t)
&lt;/pre&gt;
&lt;h3&gt;Install leiningen&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://leiningen.org&quot;&gt;leiningen&lt;/a&gt; is the &lt;i&gt;de facto&lt;/i&gt; standard for running Clojure projects.&lt;/p&gt;
&lt;p&gt;Check the very simple &lt;a href=&quot;http://leiningen.org/#install&quot;&gt;installation instructions&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Install SuperCollider&lt;/h3&gt;
&lt;p&gt;Supercollider is the audio synthetizer.&lt;/p&gt;
&lt;p&gt;You need it to play sounds with Overtone.&lt;/p&gt;
&lt;p&gt;On Debian, you can install SuperCollider the usual way: &lt;code&gt;~$ apt-get
  install supercollider&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For other platforms, see the supercollider &lt;a href=&quot;http://supercollider.sourceforge.net/downloads/&quot;&gt;downloads page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this tutorial, we will play piano, so we need the &lt;a href=&quot;http://sourceforge.net/projects/sc3-plugins/&quot;&gt;sc3-plugins&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you want to compile supercollider and sc3-plugins from sources,
  check &lt;a href=&quot;https://github.com/overtone/overtone/wiki/Compiling-SuperCollider&quot;&gt;this page&lt;/a&gt; from the Overtone wiki.&lt;/p&gt;
&lt;h3&gt;Overtone as a dependency in project.clj&lt;/h3&gt;
&lt;p&gt;Previously, we hit &lt;code&gt;C-c C-v C-t&lt;/code&gt; to tangle Emacs Lisp code blocks into
  &lt;code&gt;emacs.el&lt;/code&gt;.  Since &lt;code&gt;C-c C-v C-t&lt;/code&gt; tangles &lt;i&gt;all blocks&lt;/i&gt; in the buffer,
  we also created &lt;code&gt;project.clj&lt;/code&gt;, which is needed in order to run &lt;code&gt;lein&lt;/code&gt;
  and to let &lt;code&gt;cider&lt;/code&gt; interact with &lt;code&gt;lein&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(defproject overtone-intro &amp;quot;1.0&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.5.1&amp;quot;]
                 [overtone &amp;quot;0.9.1&amp;quot;]])
&lt;/pre&gt;
&lt;p&gt;From the &lt;code&gt;overtone-intro&lt;/code&gt; directory, run &lt;code&gt;~$ lein deps&lt;/code&gt; to load all
  dependencies.&lt;/p&gt;
&lt;h3&gt;Additional keybindings&lt;/h3&gt;
&lt;p&gt;During the live demo, I used these keybindings:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Useful keybindings when using Clojure from Org
(org-defkey org-mode-map &amp;quot;\C-x\C-e&amp;quot; &amp;#39;cider-eval-last-sexp)
(org-defkey org-mode-map &amp;quot;\C-c\C-d&amp;quot; &amp;#39;cider-doc)
&lt;/pre&gt;
&lt;p&gt;They allow to execute a Clojure source code block by hitting &lt;code&gt;C-x C-e&lt;/code&gt;
  after a Clojure sexp, and to get a Clojure docstring by hitting &lt;code&gt;C-c
  C-d&lt;/code&gt; after a symbol.&lt;/p&gt;
&lt;p&gt;If you don&amp;#8217;t use these keybindings, executing source code blocks is
  done by hitting &lt;code&gt;C-c C-c&lt;/code&gt; on the &lt;code&gt;#+BEGIN_SRC&lt;/code&gt; line.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;This is an overview of my configuration:&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Prog/Package&lt;/th&gt;&lt;th&gt;Version&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;GNU Emacs&lt;/td&gt;&lt;td&gt;24.3.50.1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;CIDER&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;auto-complete&lt;/td&gt;&lt;td&gt;1.4.0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;dash.el&lt;/td&gt;&lt;td&gt;2.3.0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;pkg-info&lt;/td&gt;&lt;td&gt;0.4&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Org-mode&lt;/td&gt;&lt;td&gt;8.2.4&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Clojure&lt;/td&gt;&lt;td&gt;1.5.1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Overtone&lt;/td&gt;&lt;td&gt;0.9.1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;The tutorial should work with older versions of Emacs, but you need to
  install Org-mode from its master branch to use &lt;a href=&quot;https://github.com/clojure-emacs/cider&quot;&gt;cider&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also, remember to hit &lt;code&gt;TAB&lt;/code&gt; for (un)folding a section or a source code
  block.&lt;/p&gt;
&lt;h2&gt;Connect to the repl&lt;/h2&gt;
&lt;p&gt;To connect the current Org buffer to a repl, run&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M-x cider-jack-in RET&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8230; and wait until you get a confirmation message in the minibuffer.&lt;/p&gt;
&lt;p&gt;Do this now, you&amp;#8217;ll need it soon.&lt;/p&gt;
&lt;h2&gt;A quick intro to Org Babel&lt;/h2&gt;
&lt;p&gt;To get a gist of what Org Babel is, hit &lt;code&gt;C-c C-c&lt;/code&gt; on the &lt;code&gt;#+BEGIN_SRC&lt;/code&gt;
  line below:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(message &amp;quot;Yeah!&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;Emacs minibuffer displays the output: yeah!&lt;/p&gt;
&lt;h3&gt;Babel: vars&lt;/h3&gt;
&lt;p&gt;You can bind variables in Babel source code blocks&amp;#8212;hit &lt;code&gt;C-c C-c&lt;/code&gt; on
  the code blocks below:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(message (number-to-string n))
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(-&amp;gt; n inc (+ m))
&lt;/pre&gt;
&lt;h3&gt;Babel: lists&lt;/h3&gt;
&lt;p&gt;Okay, you get it: hit &lt;code&gt;C-c C-c&lt;/code&gt; on code blocks to execute them.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;simple&lt;/li&gt;
  &lt;li&gt;list&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(print x)
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(map clojure.string/upper-case x)
&lt;/pre&gt;
&lt;h3&gt;Babel: tables&lt;/h3&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;a&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;b&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;c&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;d&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
data
&lt;/pre&gt;
&lt;h2&gt;A quick intro to Overtone&lt;/h2&gt;
&lt;h3&gt;Overtone: loading and booting&lt;/h3&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(use &amp;#39;overtone.core)
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(boot-external-server)
&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: I&amp;#8217;m using GNU/Linux, and I didn&amp;#8217;t take the time to configure
  jackd properly.  You may want to use this instead:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(use &amp;#39;overtone.live)
(boot-internal-server)
&lt;/pre&gt;
&lt;h3&gt;Overtone: playing/fooling around&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: the first time you use the &lt;code&gt;overtone.inst.piano&lt;/code&gt; namespace, it
  will load quite a lot of files from freesound.org &amp;#8211; you may want to
  do this within a bare &lt;code&gt;lein repl&lt;/code&gt; in order to make sure the process is
  over.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(use &amp;#39;overtone.inst.piano)
&lt;/pre&gt;
&lt;p&gt;Play a simple midi note:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(piano 60)
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(doseq [note (chord :C3)] (piano note))
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(doseq [note (chord :E3 :minor)] (piano note))
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(defn play-chord [chord]
  (doseq [note chord] (piano note)))

(play-chord (chord :A3 :minor))
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(let [time (now)]
  (at time (play-chord (chord :C3 :major)))
  (at (+ 1000 time) (play-chord (chord :C3 :major7)))
  (at (+ 2000 time) (play-chord (chord :E3 :minor)))
  (at (+ 3000 time) (play-chord (chord :A2 :minor))))
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;defsynth&lt;/code&gt; and &lt;code&gt;definst&lt;/code&gt; are the two entry points for creating sounds
  and instruments &amp;#8211; go check their docstrings, they explain a lot.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(defsynth bar [freq 440]
  (out 0 (sin-osc freq)))

(bar 500)
(kill bar)
(stop)

(definst beep [note 60]
  (let [sound-src (sin-osc (midicps note))
	 env (env-gen (perc 0.01 1.0) :action FREE)] ; sam uses :free
    (* sound-src env)))

(beep 60)

(defsynth pad1 [freq 110 amp 1 gate 1 out-bus 0]
  (out out-bus
	(* (saw [freq (* freq 1.01)])
	   (env-gen (adsr 0.01 0.1 0.7 0.5) :gate gate :action FREE))))

(pad1)
(stop)

;; Let&amp;#39;s try something a bit crazy
(for [i (range 200)] (at (+ (now) (* i 20)) (beep i)))
&lt;/pre&gt;
&lt;p&gt;Some more copy-and-paste from overtone&amp;#8217;s wiki:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(map piano [60 63 67])
(map piano (map note [:C3 :E4 :G4]))
(map piano (map note [:C#5 :E4 :G4]))
(map piano (map note [:Cb2 :E4 :G4]))

(definst steel-drum [note 60 amp 0.8]
  (let [freq (midicps note)]
    (* amp
	(env-gen (perc 0.01 0.2) 1 1 0 1 :action FREE)
	(+ (sin-osc (/ freq 2))
	   (rlpf (saw freq) (* 1.1 freq) 0.4)))))

(steel-drum (note :E3))
(map steel-drum (map note [:E3 :D#4]))
&lt;/pre&gt;
&lt;h3&gt;Overtone: loading .wav samples&lt;/h3&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
;; Hint: adapt this to your own .wav files
(def noa (sample &amp;quot;/path/to/a/file.wav&amp;quot;))

(let []
  (noa)
  (Thread/sleep 3000)
  (piano (note :Cb3))
  (piano 68))

(stop)
&lt;/pre&gt;
&lt;h3&gt;Overtone: using freesound.org&lt;/h3&gt;
&lt;p&gt;You can download samples directly from freesound.org via Overtone:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;clojure&quot;&gt;
(def snare (sample (freesound-path 26903)))
(snare)
(def clic (sample (freesound-path 406)))
(clic)
(def steam (sample (freesound-path 30628)))
(steam)
(def clap (sample (freesound-path 48310)))
(clap)
(def clap2 (sample (freesound-path 132676)))
(clap2)
(def boom (sample (freesound-path 80401)))
(boom)
&lt;/pre&gt;
&lt;h2&gt;Why I love this?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;I love sounds.&lt;/li&gt;
  &lt;li&gt;I love Org+Cider &lt;i&gt;reactivity&lt;/i&gt;: evaluating Clojure sexps is fast.&lt;/li&gt;
  &lt;li&gt;I love building (mostly random) sounds so fast, it feels like
    &lt;i&gt;sculpting&lt;/i&gt; music.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Issues&lt;/h2&gt;
&lt;p&gt;If you run into issues while following this tutorial, please report
  them on &lt;a href=&quot;https://github.com/bzg/org-overtone-intro&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Exploring further&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://github.com/overtone/overtone&lt;/li&gt;
  &lt;li&gt;https://github.com/overtone/overtone/blob/master/src/overtone/samples/freesound.clj&lt;/li&gt;
  &lt;li&gt;http://skillsmatter.com/podcast/home/functional-composition&lt;/li&gt;
  &lt;li&gt;http://blog.josephwilk.net/clojure/creating-instruments-with-overtone.html&lt;/li&gt;
  &lt;li&gt;http://www.tonalsoft.com/pub/news/pitch-bend.aspx&lt;/li&gt;
  &lt;li&gt;http://www.freesound.org/&lt;/li&gt;
&lt;/ul&gt;


</description>
        <pubDate>Sat, 21 Dec 2013 00:00:00 +0100</pubDate>
        <link>https://emacs-doctor.com/emacs-org-babel-overtone-intro.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/emacs-org-babel-overtone-intro.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Blogging from GNU Emacs</title>
        <description>
&lt;p&gt;Yes, blogging from Emacs is possible.&lt;/p&gt;
&lt;p&gt;If you are familiar with &lt;a href=&quot;http://orgmode.org&quot;&gt;org-mode&lt;/a&gt; and if you already know how to
  publish a HTML project, this is straightforward: just download
  &lt;a href=&quot;http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ox-rss.el&quot;&gt;ox-rss.el&lt;/a&gt; and follow the instructions in the comment section.&lt;/p&gt;
&lt;p&gt;If you are not so familiar with Org-mode, or with publishing HTML
  project (or just enjoy reviewing the basics from time to time), here
  is a small tutorial describing the steps to let you enjoy an Emacs
  blog.&lt;/p&gt;
&lt;h2&gt;Org-mode 15 seconds introduction&lt;/h2&gt;
&lt;p&gt;Fire up GNU Emacs.&lt;/p&gt;
&lt;p&gt;Then hit &lt;code&gt;C-x C-f ~/my-blog.org RET&lt;/code&gt; to create a new Org file named
  &lt;code&gt;my-blog.org&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this file, hit &lt;code&gt;M-RET&lt;/code&gt; to insert a new heading.  Type something
  sensible as the title of your next blog entry:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;org&quot;&gt;
* My first blog post with Emacs and Org!

This will be the content of my blog entry.
&lt;/pre&gt;
&lt;p&gt;You&amp;#8217;re done.&lt;/p&gt;
&lt;h2&gt;Publishing &lt;code&gt;my-blog.org&lt;/code&gt; as a HTML page&lt;/h2&gt;
&lt;p&gt;You need to publish your Org page somewhere in your computer.&lt;/p&gt;
&lt;p&gt;So let&amp;#8217;s create a &lt;code&gt;public_html/&lt;/code&gt; directory in your home directory:&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
~$ mkdir public_html
&lt;/pre&gt;
&lt;p&gt;Now edit your &lt;code&gt;.emacs.el&lt;/code&gt; file and add this Emacs lisp snippet:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(setq org-publish-project-alist
      &amp;#39;((&amp;quot;blog&amp;quot;
         :base-directory &amp;quot;~/&amp;quot;
         :html-extension &amp;quot;html&amp;quot;
         :base-extension &amp;quot;org&amp;quot;
         :publishing-directory &amp;quot;~/public_html/&amp;quot;
         :publishing-function (org-html-publish-to-html)
         :html-preamble nil
         :html-postamble nil)))
&lt;/pre&gt;
&lt;p&gt;The code above defines a HTML &lt;i&gt;publishing&lt;/i&gt; project with no preamble
  and no postamble.  (To learn more on publishing projects, please read
  the &lt;a href=&quot;http://orgmode.org/manual/Publishing.html&quot;&gt;Org manual&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Evaluate this code by hitting &lt;code&gt;C-x e&lt;/code&gt; at the end of the last
  parenthesis.&lt;/p&gt;
&lt;p&gt;Now hit &lt;code&gt;M-x org-publish RET blog RET&lt;/code&gt; anywhere in Emacs to publish
  the project.&lt;/p&gt;
&lt;p&gt;Your &lt;code&gt;public_html/&lt;/code&gt; directory now contains a new file, &lt;code&gt;my-blog.html&lt;/code&gt;,
  with a HTML export of your &lt;code&gt;my-blog.org&lt;/code&gt; file.&lt;/p&gt;
&lt;h2&gt;Publishing &lt;code&gt;my-blog.org&lt;/code&gt; as a RSS feed&lt;/h2&gt;
&lt;p&gt;You want to publish this page as a RSS feed so that readers can
  subscribe to it.  (Yes, my own definition of a blog is &lt;i&gt;that&lt;/i&gt; simple:
  some HTML content and a feed.)&lt;/p&gt;
&lt;p&gt;You are three steps away from having a blog&amp;#8212;you only need to:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;load &lt;code&gt;ox-rss.el&lt;/code&gt; to enable RSS publishing;&lt;/li&gt;
  &lt;li&gt;create a RSS publishing project;&lt;/li&gt;
  &lt;li&gt;add some RSS-related info in your HTML publishing project.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Enable RSS publishing&lt;/h3&gt;
&lt;p&gt;Find ox-rss.el in Org&amp;#8217;s &lt;code&gt;contrib/lisp/&lt;/code&gt; directory and make sure this
  directory is in your Emacs load-path.&lt;/p&gt;
&lt;p&gt;Since Org lives in the &lt;code&gt;~/install/git/&lt;/code&gt; contrib on my computer, this
  is my configuration:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(add-to-list &amp;#39;load-path &amp;quot;~/install/git/org-mode/contrib/lisp/&amp;quot;)
(require &amp;#39;ox-rss)
&lt;/pre&gt;
&lt;p&gt;(We use &lt;code&gt;add-to-list&lt;/code&gt; to append a new project to
  &lt;code&gt;org-publish-project-alist&lt;/code&gt;, but you can simply use &lt;code&gt;setq&lt;/code&gt; with both
  projects on &lt;code&gt;org-publish-project-alist&lt;/code&gt;.)&lt;/p&gt;
&lt;h3&gt;Create a RSS publishing project&lt;/h3&gt;
&lt;p&gt;Add this new RSS publishing project:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(add-to-list &amp;#39;org-publish-project-alist
             &amp;#39;(&amp;quot;blog-rss&amp;quot;
		:base-directory &amp;quot;~/&amp;quot;
		:base-extension &amp;quot;org&amp;quot;
		:publishing-directory &amp;quot;~/public_html/&amp;quot;
		:publishing-function (org-rss-publish-to-rss)
		:html-link-home &amp;quot;http://mydomain.org/&amp;quot;
		:html-link-use-abs-url t))
&lt;/pre&gt;
&lt;p&gt;It is pretty similar to our HTML publishing project except that:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the publishing function we use is &lt;code&gt;org-rss-publish-to-rss&lt;/code&gt; instead
    of &lt;code&gt;org-html-publish-to-html&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;we set the &lt;code&gt;:html-link-home&lt;/code&gt; publishing option so that relative
    links in our RSS feed are prefixed with the &amp;#8220;http://mydomain.org/&amp;#8221;
    domain name (assuming it will be the final destination of our blog);&lt;/li&gt;
  &lt;li&gt;we set the &lt;code&gt;:html-link-use-abs-url&lt;/code&gt; publishing option to &lt;code&gt;t&lt;/code&gt; (true)
    so that all links in our RSS feed are absolute, since it does not
    make sense to have relative links in RSS feeds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Evaluate the code above with &lt;code&gt;C-x e&lt;/code&gt; then hit &lt;code&gt;M-x org-publish RET
  blog-rss RET&lt;/code&gt; to publish the RSS feed: &lt;code&gt;public_html/&lt;/code&gt; now contains a
  &lt;code&gt;my-blog.xml&lt;/code&gt; file along with the &lt;code&gt;my-blog.html&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Add some RSS-related info in your HTML publishing project&lt;/h3&gt;
&lt;p&gt;Our last step is to link our RSS feed (the &lt;code&gt;my-blog.xml&lt;/code&gt; file) with
  the HTML file.  Let&amp;#8217;s rewrite our HTML project like this:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(setq org-publish-project-alist
      &amp;#39;((&amp;quot;blog&amp;quot;
         :base-directory &amp;quot;~/&amp;quot;
         :html-extension &amp;quot;html&amp;quot;
         :base-extension &amp;quot;org&amp;quot;
         :publishing-directory &amp;quot;~/public_html/&amp;quot;
         :publishing-function (org-html-publish-to-html)
         :html-preamble nil
         :html-postamble nil
         :html-head-extra
         &amp;quot;&amp;lt;link rel=\&amp;quot;alternate\&amp;quot; type=\&amp;quot;application/rss+xml\&amp;quot;
                href=\&amp;quot;http://mydomain.org/my-blog.xml\&amp;quot;
                title=\&amp;quot;RSS feed for mydomain.org\&amp;quot;&amp;gt;&amp;quot;)))
&lt;/pre&gt;
&lt;p&gt;We just appended the &lt;code&gt;:html-head-extra&lt;/code&gt; option, which tells what
  information we want to add in our HTML &lt;code&gt;&amp;lt;head&amp;gt;...&amp;lt;/head&amp;gt;&lt;/code&gt; section.&lt;/p&gt;
&lt;h2&gt;Last but not least: a real setup&lt;/h2&gt;
&lt;p&gt;Okay, you now have a single file, with a RSS feed that points to
  headlines in this file.  But what if you want to allow readers to
  &lt;i&gt;comment&lt;/i&gt; your blog posts?&lt;/p&gt;
&lt;p&gt;In this case, you need to have &lt;i&gt;one page per blog entry&lt;/i&gt; and to use
  something like &lt;a href=&quot;http://disqus.com&quot;&gt;disqus.com&lt;/a&gt; to enable comments on this page.&lt;/p&gt;
&lt;p&gt;This is perfectly &lt;i&gt;fine&lt;/i&gt;!&lt;/p&gt;
&lt;p&gt;Just write your blog posts in dedicated .org files, then use the
  &lt;code&gt;my-blog.org&lt;/code&gt; file as a collection of &lt;i&gt;summaries&lt;/i&gt; of your blog posts.
  At the end of each summary, put a link to the Org page where people
  can comment.&lt;/p&gt;
&lt;p&gt;Then update your RSS publishing project like this:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
(add-to-list &amp;#39;org-publish-project-alist
             &amp;#39;(&amp;quot;blog-rss&amp;quot;
		:base-directory &amp;quot;~/&amp;quot;
		:base-extension &amp;quot;org&amp;quot;
		:publishing-directory &amp;quot;~/public_html/&amp;quot;
		:publishing-function (org-rss-publish-to-rss)
		:html-link-home &amp;quot;http://mydomain.org/&amp;quot;
		:html-link-use-abs-url t
		:exclude &amp;quot;.*&amp;quot;
		:include (&amp;quot;my-blog.org&amp;quot;)))
&lt;/pre&gt;
&lt;p&gt;Note the options &lt;code&gt;:exclude&lt;/code&gt; and &lt;code&gt;:include&lt;/code&gt;&amp;#8212;they say: &amp;#8220;Don&amp;#8217;t publish
  .xml files for all .org files in the base directory, only publish a
  .xml file for &lt;code&gt;my-blog.org&lt;/code&gt;.&amp;#8221;&lt;/p&gt;
&lt;p&gt;This setup may sound weird first, but I find it useful on the long
  term: quick thoughts get directly in the main &lt;code&gt;my-blog.org&lt;/code&gt; file, and
  longer blogs have their dedicated pages, with comments allowed.&lt;/p&gt;
&lt;h2&gt;Going beyond&lt;/h2&gt;
&lt;p&gt;Of course: you can do a lot more than that&amp;#8212;here is a quick list:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;embed pictures;&lt;/li&gt;
  &lt;li&gt;embed arbitrary HTML code;&lt;/li&gt;
  &lt;li&gt;embed code snippets (zero headache to get syntax highlighting);&lt;/li&gt;
  &lt;li&gt;tweak your RSS publishing project to skip TODO headlines&lt;/li&gt;
  &lt;li&gt;use timestamps for drafts that need to be published later;&lt;/li&gt;
  &lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you are not afraid of raw code with too few comments, you can dive
  into my &lt;a href=&quot;http://bzg.fr/emacs.html&quot;&gt;.emacs.el&lt;/a&gt; and grab hints from my configuration.&lt;/p&gt;
&lt;h2&gt;Why this is cool?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Writing in Emacs is just pure delight.&lt;/li&gt;
  &lt;li&gt;Blog posts are now part of your Org agenda.&lt;/li&gt;
  &lt;li&gt;If you already have a habit of taking your notes in Org, then you&amp;#8217;ll
    more easily take a habit of publishing blog posts from these notes.&lt;/li&gt;
  &lt;li&gt;Since Org files are plain text, storing a blog as a git repository
    feels natural: people can contribute your blog with&amp;#8230; patches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ox-rss.el&lt;/code&gt; is not very well known so far, I hope this blog post will
  encourage people to use it!  Let me know if something is not clear.&lt;/p&gt;
&lt;h2&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;You need to use Emacs version 24.2.1 (or later) and Org 8.0
  (or later).&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks to Sacha Chua&amp;#8217;s post here about &lt;a href=&quot;http://sachachua.com/blog/2013/09/when-i-blog-with-emacs-and-when-i-blog-with-something-else/&quot;&gt;blogging with Emacs&lt;/a&gt;, as this
  triggered me to write this post!  Her post is worth exploring for the
  links it contains to other Emacs-based solutions I didn&amp;#8217;t mentioned
  here&amp;#8230; but I&amp;#8217;m sure you&amp;#8217;ll discuss them in the comments.&lt;/p&gt;


</description>
        <pubDate>Wed, 25 Sep 2013 00:00:00 +0200</pubDate>
        <link>https://emacs-doctor.com/blogging-from-emacs.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/blogging-from-emacs.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Learn Emacs Lisp in 15 minutes</title>
        <description>
&lt;p&gt;I was surprised not to find an introduction to Emacs Lisp on
  &lt;a href=&quot;http://learnxinyminutes.com&quot;&gt;http://learnxinyminutes.com&lt;/a&gt; so I created one.  This page is now on
  http://learnxinyminutes.com/docs/elisp/ too.&lt;/p&gt;
&lt;p&gt;Comments and feedback are welcome !&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; This gives an introduction to Emacs Lisp in 15 minutes (v0.2d)
;;
;; Author: Bastien / @bzg2 / https://bzg.fr
;;
;; First make sure you read this text by Peter Norvig:
;; http://norvig.com/21-days.html
;;
;; Then install GNU Emacs 24.3:
;;
;; Debian: apt-get install emacs (or see your distro instructions)
;; MacOSX: http://emacsformacosx.com/emacs-builds/Emacs-24.3-universal-10.6.8.dmg
;; Windows: http://ftp.gnu.org/gnu/windows/emacs/emacs-24.3-bin-i386.zip
;;
;; More general information can be found at:
;; http://www.gnu.org/software/emacs/#Obtaining

;; Important warning:
;;
;; Going through this tutorial won&amp;#39;t damage your computer unless
;; you get so angry that you throw it on the floor.  In that case,
;; I hereby decline any responsability.  Have fun!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; Fire up Emacs.
;;
;; Hit the `q&amp;#39; key to dismiss the welcome message.
;;
;; Now look at the gray line at the bottom of the window:
;;
;; &amp;quot;*scratch*&amp;quot; is the name of the editing space you are now in.
;; This editing space is called a &amp;quot;buffer&amp;quot;.
;;
;; The scratch buffer is the default buffer when opening Emacs.
;; You are never editing files: you are editing buffers that you
;; can save to a file.
;; 
;; &amp;quot;Lisp interaction&amp;quot; refers to a set of commands available here.
;; 
;; Emacs has a built-in set of commands available in every buffer,
;; and several subsets of commands available when you activate a
;; specific mode.  Here we use the `lisp-interaction-mode&amp;#39;, which
;; comes with commands to evaluate and navigate within Elisp code.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Semi-colons start comments anywhere on a line.
;;
;; Elisp programs are made of symbolic expressions (&amp;quot;sexps&amp;quot;):
(+ 2 2)

;; This symbolic expression reads as &amp;quot;Add 2 to 2&amp;quot;.

;; Sexps are enclosed into parentheses, possibly nested:
(+ 2 (+ 1 1))

;; A symbolic expression contains atoms or other symbolic
;; expressions.  In the above examples, 1 and 2 are atoms,
;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.

;; From `lisp-interaction-mode&amp;#39; you can evaluate sexps.
;; Put the cursor right after the closing parenthesis then
;; hold down the control and hit the j keys (&amp;quot;C-j&amp;quot; for short).

(+ 3 (+ 1 2))
;;           ^ cursor here
;; `C-j&amp;#39; =&amp;gt; 6

;; `C-j&amp;#39; inserts the result of the evaluation in the buffer.

;; `C-x C-e&amp;#39; displays the same result in Emacs bottom line,
;; called the &amp;quot;minibuffer&amp;quot;.  We will generally use `C-x C-e&amp;#39;,
;; as we don&amp;#39;t want to clutter the buffer with useless text.

;; `setq&amp;#39; stores a value into a variable:
(setq my-name &amp;quot;Bastien&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Bastien&amp;quot; (displayed in the mini-buffer)

;; `insert&amp;#39; will insert &amp;quot;Hello!&amp;quot; where the cursor is:
(insert &amp;quot;Hello!&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello!&amp;quot;

;; We used `insert&amp;#39; with only one argument &amp;quot;Hello!&amp;quot;, but
;; we can pass more arguments -- here we use two:

(insert &amp;quot;Hello&amp;quot; &amp;quot; world!&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello world!&amp;quot;

;; You can use variables instead of strings:
(insert &amp;quot;Hello, I am &amp;quot; my-name)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello, I am Bastien&amp;quot;

;; You can combine sexps into functions:
(defun hello () (insert &amp;quot;Hello, I am &amp;quot; my-name))
;; `C-x C-e&amp;#39; =&amp;gt; hello

;; You can evaluate functions:
(hello)
;; `C-x C-e&amp;#39; =&amp;gt; Hello, I am Bastien

;; The empty parentheses in the function&amp;#39;s definition means that
;; it does not accept arguments.  But always using `my-name&amp;#39; is
;; boring, let&amp;#39;s tell the function to accept one argument (here
;; the argument is called &amp;quot;name&amp;quot;): 

(defun hello (name) (insert &amp;quot;Hello &amp;quot; name))
;; `C-x C-e&amp;#39; =&amp;gt; hello

;; Now let&amp;#39;s call the function with the string &amp;quot;you&amp;quot; as the value
;; for its unique argument:
(hello &amp;quot;you&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello you&amp;quot;

;; Yeah!

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Now switch to a new buffer named &amp;quot;*test*&amp;quot; in another window:

(switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
;; `C-x C-e&amp;#39;
;; =&amp;gt; [screen has two windows and cursor is in the *test* buffer]

;; Mouse over the top window and left-click to go back.  Or you can
;; use `C-x o&amp;#39; (i.e. hold down control-x and hit o) to go to the other
;; window interactively.

;; You can combine several sexps with `progn&amp;#39;:
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (hello &amp;quot;you&amp;quot;))
;; `C-x C-e&amp;#39;
;; =&amp;gt; [The screen has two windows and cursor is in the *test* buffer]

;; Now if you don&amp;#39;t mind, I&amp;#39;ll stop asking you to hit `C-x C-e&amp;#39;: do it
;; for every sexp that follows.

;; Always go back to the *scratch* buffer with the mouse or `C-x o&amp;#39;.

;; It&amp;#39;s often useful to erase the buffer:
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello &amp;quot;there&amp;quot;))

;; Or to go back to the other window:
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello &amp;quot;you&amp;quot;)
  (other-window 1))

;; You can bind a value to a local variable with `let&amp;#39;:
(let ((local-name &amp;quot;you&amp;quot;))
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello local-name)
  (other-window 1))

;; No need to use `progn&amp;#39; in that case, since `let&amp;#39; also combines
;; several sexps.

;; Let&amp;#39;s format a string:
(format &amp;quot;Hello %s!\n&amp;quot; &amp;quot;visitor&amp;quot;)

;; %s is a place-holder for a string, replaced by &amp;quot;visitor&amp;quot;.
;; \n is the newline character.

;; Let&amp;#39;s refine our function by using format:
(defun hello (name)
  (insert (format &amp;quot;Hello %s!\n&amp;quot; name)))

(hello &amp;quot;you&amp;quot;)

;; Let&amp;#39;s create another function which uses `let&amp;#39;:
(defun greeting (name)
  (let ((your-name &amp;quot;Bastien&amp;quot;))
    (insert (format &amp;quot;Hello %s!\n\nI am %s.&amp;quot;
                    name       ; the argument of the function
                    your-name  ; the let-bound variable &amp;quot;Bastien&amp;quot;
                    ))))

;; And evaluate it:
(greeting &amp;quot;you&amp;quot;)

;; Some function are interactive:
(read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)

;; Evaluating this function returns what you entered at the prompt.

;; Let&amp;#39;s make our `greeting&amp;#39; function prompt for your name:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)))
    (insert (format &amp;quot;Hello!\n\nI am %s and you are %s.&amp;quot;
                    from-name ; the argument of the function
                    your-name ; the let-bound var, entered at prompt
                    ))))

(greeting &amp;quot;Bastien&amp;quot;)

;; Let&amp;#39;s complete it by displaying the results in the other window:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)))
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    (insert (format &amp;quot;Hello %s!\n\nI am %s.&amp;quot; your-name from-name))
    (other-window 1)))

;; Now test it:
(greeting &amp;quot;Bastien&amp;quot;)

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Let&amp;#39;s store a list of names:
(setq list-of-names &amp;#39;(&amp;quot;Sarah&amp;quot; &amp;quot;Chloe&amp;quot; &amp;quot;Mathilde&amp;quot;))

;; Get the first element of this list with `car&amp;#39;:
(car list-of-names)

;; Get a list of all but the first element with `cdr&amp;#39;:
(cdr list-of-names)

;; Add an element to the beginning of a list with `push&amp;#39;:
(push &amp;quot;Stephanie&amp;quot; list-of-names)

;; NOTE: `car&amp;#39; and `cdr&amp;#39; don&amp;#39;t modify the list, but `push&amp;#39; does.
;; This is an important difference: some functions don&amp;#39;t have any
;; side-effects (like `car&amp;#39;) while others have (like `push&amp;#39;).

;; Let&amp;#39;s call `hello&amp;#39; for each element in `list-of-names&amp;#39;:
(mapcar &amp;#39;hello list-of-names)

;; Refine `greeting&amp;#39; to say hello to everyone in `list-of-names&amp;#39;:
(defun greeting ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    (mapcar &amp;#39;hello list-of-names)
    (other-window 1))

(greeting)

;; Remember the `hello&amp;#39; function we defined above?  It takes one
;; argument, a name.  `mapcar&amp;#39; calls `hello&amp;#39;, successively using each
;; element of `list-of-names&amp;#39; as the argument for `hello&amp;#39;.

;; Now let&amp;#39;s arrange a bit what we have in the displayed buffer:

(defun replace-hello-by-bonjour ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (goto-char (point-min))
    (while (search-forward &amp;quot;Hello&amp;quot;)
      (replace-match &amp;quot;Bonjour&amp;quot;))
    (other-window 1))

;; (goto-char (point-min)) goes to the beginning of the buffer.
;; (search-forward &amp;quot;Hello&amp;quot;) searches for the string &amp;quot;Hello&amp;quot;.
;; (while x y) evaluates the y sexp(s) while x returns something.
;; If x returns `nil&amp;#39; (nothing), we exit the while loop.

(replace-hello-by-bonjour)

;; You should see all occurrences of &amp;quot;Hello&amp;quot; in the *test* buffer
;; replaced by &amp;quot;Bonjour&amp;quot;.

;; You should also get an error: &amp;quot;Search failed: Hello&amp;quot;.
;;
;; To avoid this error, you need to tell `search-forward&amp;#39; whether it
;; should stop searching at some point in the buffer, and whether it
;; should silently fail when nothing is found:

;; (search-forward &amp;quot;Hello&amp;quot; nil t) does the trick:

;; The `nil&amp;#39; argument says: the search is not bound to a position.
;; The `t&amp;#39; argument says: silently fail when nothing is found.

;; We use this sexp in the function below, which doesn&amp;#39;t throw an error:

(defun hello-to-bonjour ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    ;; Say hello to names in `list-of-names&amp;#39;
    (mapcar &amp;#39;hello list-of-names)
    (goto-char (point-min))
    ;; Replace &amp;quot;Hello&amp;quot; by &amp;quot;Bonjour&amp;quot;
    (while (search-forward &amp;quot;Hello&amp;quot; nil t)
      (replace-match &amp;quot;Bonjour&amp;quot;))
    (other-window 1))

(hello-to-bonjour)

;; Let&amp;#39;s colorize the names:

(defun boldify-names ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (goto-char (point-min))
    (while (re-search-forward &amp;quot;Bonjour \\(.+\\)!&amp;quot; nil t)
      (add-text-properties (match-beginning 1)
                           (match-end 1)
                           (list &amp;#39;face &amp;#39;bold)))
    (other-window 1))

;; This functions introduces `re-search-forward&amp;#39;: instead of
;; searching for the string &amp;quot;Bonjour&amp;quot;, you search for a pattern,
;; using a &amp;quot;regular expression&amp;quot; (abbreviated in the prefix &amp;quot;re-&amp;quot;).

;; The regular expression is &amp;quot;Bonjour \\(.+\\)!&amp;quot; and it reads:
;; the string &amp;quot;Bonjour &amp;quot;, and
;; a group of           | this is the \\( ... \\) construct
;;   any character      | this is the .
;;   possibly repeated  | this is the +
;; and the &amp;quot;!&amp;quot; string.

;; Ready?  Test it!

(boldify-names)

;; `add-text-properties&amp;#39; adds... text properties, like a face.

;; OK, we are done.  Happy hacking!

;; If you want to know more about a variable or a function:
;;
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; To read the Emacs Lisp manual with Emacs:
;;
;; C-h i m elisp RET
;;
;; To read an online introduction to Emacs Lisp:
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html

;; Thanks to these people for their feedback and suggestions:
;; - Wes Hardaker
;; - notbob
;; - Kevin Montuori
;; - Arne Babenhauserheide
;; - Alan Schmitt
;; - LinXitoW
;; - Aaron Meurer

&lt;/pre&gt;


</description>
        <pubDate>Thu, 25 Jul 2013 00:00:00 +0200</pubDate>
        <link>https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
      <item>
        <title>Apprendre Emacs Lisp en 15 minutes</title>
        <description>
&lt;p&gt;Les commentaires et les retours sont les bienvenus !&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;emacs-lisp&quot;&gt;
;; Ceci est une introduction à Emacs Lisp en 15 minutes (v0.2d)
;;
;; Auteur : Bastien / @bzg2 / https://bzg.fr
;;
;; Prenez d&amp;#39;abord le temps de lire ce texte en anglais de Peter Norvig :
;; http://norvig.com/21-days.html
;;
;; Ensuite installez GNU Emacs 24.3 (ou une version ultérieure) :
;;
;; Debian : apt-get install emacs (voir les instructions pour votre distribution)
;; MacOSX : http://emacsformacosx.com/emacs-builds/Emacs-24.3-universal-10.6.8.dmg
;; Windows : http://ftp.gnu.org/gnu/windows/emacs/emacs-24.3-bin-i386.zip
;;
;; Vous trouverez plus d&amp;#39;informations sur l&amp;#39;installation :
;; http://www.gnu.org/software/emacs/#Obtaining

;; Avertissement important :
;;
;; Suivre ce tutoriel ne risque pas d&amp;#39;endommager votre ordinateur,
;; sauf si vous vous énervez au point de le jeter par terre.  En tout
;; cas, je décline toute responsabilité en cas de problème.
;; Amusez-vous bien !

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; Lancez Emacs.
;;
;; Tapez la touche `q&amp;#39; pour enlever le message d&amp;#39;accueil.
;;
;; Maintenant regardez la ligne grise au pied de la fenêtre :
;;
;; &amp;quot;*scratch*&amp;quot; est le nom de l&amp;#39;espace d&amp;#39;édition dans lequel vous vous
;; trouvez.  Cet espace d&amp;#39;édition est appelé un &amp;quot;buffer&amp;quot;.
;;
;; Le buffer scratch est le buffer par défaut quand on ouvre Emacs.
;; Vous n&amp;#39;éditez jamais de fichier directement : vous éditez des
;; buffers que vous pouvez sauvegarder dans des fichiers.
;; 
;; &amp;quot;Lisp interaction&amp;quot; désigne le jeu de commandes disponible ici.
;; 
;; Emacs a un jeu de commandes par défaut pour chaque buffer, et
;; plusieurs autres jeux de commandes disponibles quand vous activez
;; un mode particulier.  Ici nous utilisons `lisp-interaction-mode&amp;#39;,
;; qui propose des commandes pour évaluer et naviguer dans du code
;; Elisp.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Le point-virgule commence un commentaire partout sur une ligne.
;;
;; Les programmes Elisp sont composés d&amp;#39;expressions symboliques aussi
;; appelées &amp;quot;sexps&amp;quot; :
(+ 2 2)

;; Cette expression symbolique se lit &amp;quot;Ajouter 2 à 2&amp;quot;.

;; Les sexps sont placées entre parenthèses, possiblement sur
;; plusieurs niveaux :
(+ 2 (+ 1 1))

;; Une expression symbolique contient des atomes ou d&amp;#39;autres
;; expressions symboliques.  Dans les exemples ci-dessus, 1 et 2 sont
;; des atomes et (+ 2 (+ 1 1)) et (+ 1 1) des expressions symboliques.

;; Dans le mode `lisp-interaction-mode&amp;#39; vous pouvez évaluer les sexps.
;; Placez le curseur juste après la parenthèse fermante, tenez la
;; touche &amp;quot;Control&amp;quot; enfoncée et appuyez sur la touche &amp;quot;j&amp;quot; (soit le
;; raccourci &amp;quot;C-j&amp;quot;).

(+ 3 (+ 1 2))
;;           ^ curseur ici
;; `C-j&amp;#39; =&amp;gt; 6

;; `C-j&amp;#39; insère le résultat de l&amp;#39;évaluation dans le buffer.

;; `C-x C-e&amp;#39; affiche le même résultat dans la ligne tout en bas
;; d&amp;#39;Emacs, appelée le &amp;quot;minibuffer&amp;quot;.  On utilise en général `C-x C-e&amp;#39;,
;; pour ne pas encombrer le buffer avec du texte inutile.

;; `setq&amp;#39; assigne une valeur à une variable :
(setq my-name &amp;quot;Bastien&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Bastien&amp;quot; (affiché dans le minibuffer)

;; `insert&amp;#39; va insérer &amp;quot;Hello!&amp;quot; là où se trouve le curseur :
(insert &amp;quot;Hello!&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello!&amp;quot;

;; Nous utilisons `insert&amp;#39; avec un seul argument &amp;quot;Hello!&amp;quot;, mais
;; nous pouvons passer plus d&amp;#39;arguments - ici nous en passons deux :

(insert &amp;quot;Hello&amp;quot; &amp;quot; world!&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello world!&amp;quot;

;; Vous pouvez utiliser des variables au lieu de chaînes de caractères :
(insert &amp;quot;Hello, I am &amp;quot; my-name)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello, I am Bastien&amp;quot;

;; Vous pouvez combiner les sexps en fonctions :
(defun hello () (insert &amp;quot;Hello, I am &amp;quot; my-name))
;; `C-x C-e&amp;#39; =&amp;gt; hello

;; Vous pouvez évaluer les fonctions :
(hello)
;; `C-x C-e&amp;#39; =&amp;gt; Hello, I am Bastien

;; Les parenthèses vides dans la définition de la fonction signifient
;; qu&amp;#39;elle ne prend pas d&amp;#39;argument.  Mais toujours utiliser `my-name&amp;#39;
;; est ennuyant, demandons à la fonction d&amp;#39;accepter un argument (ici
;; l&amp;#39;argument est appelé &amp;quot;name&amp;quot;) :

(defun hello (name) (insert &amp;quot;Hello &amp;quot; name))
;; `C-x C-e&amp;#39; =&amp;gt; hello

;; Maintenant appelons la fonction avec la chaîne de caractères &amp;quot;you&amp;quot;
;; comme valeur de son unique argument :
(hello &amp;quot;you&amp;quot;)
;; `C-x C-e&amp;#39; =&amp;gt; &amp;quot;Hello you&amp;quot;

;; Youpi!

;; Faites une pause.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Maintenant ouvrez un nouveau buffer appelé &amp;quot;*test*&amp;quot; dans une
;; nouvelle fenêtre :

(switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
;; `C-x C-e&amp;#39;
;; =&amp;gt; [l&amp;#39;écran a deux fenêtres et le curseur est dans le buffer *test*]

;; Placez la souris sur la fenêtre du haut et cliquez-gauche pour
;; retourner dans cette fenêtre.  Ou bien utilisez `C-x o&amp;#39; (i.e. tenez
;; control-x appuyé et appuyez sur o) pour aller dans l&amp;#39;autre fenêtre
;; interactivement.

;; Vous pouvez combiner plusieurs sexps avec `progn&amp;#39; :
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (hello &amp;quot;you&amp;quot;))
;; `C-x C-e&amp;#39;
;; =&amp;gt; [L&amp;#39;écran a deux fenêtres et le curseur est dans le buffer *test*]

;; Maintenant si ça ne vous dérange pas, je vais arrêter de vous
;; demander de faire `C-x C-e&amp;#39; : faites-le pour chaque sexp qui suit.

;; Retournez toujours dans le buffer *scratch* avec la souris ou `C-x o&amp;#39;.

;; Il est souvent utile d&amp;#39;effacer le contenu du buffer :
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello &amp;quot;there&amp;quot;))

;; Ou d&amp;#39;aller à l&amp;#39;autre fenêtre :
(progn
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello &amp;quot;you&amp;quot;)
  (other-window 1))

;; Vous pouvez associer une valeur à une variable locale avec `let&amp;#39; :
(let ((local-name &amp;quot;you&amp;quot;))
  (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
  (erase-buffer)
  (hello local-name)
  (other-window 1))

;; Dans ce cas pas besoin d&amp;#39;utiliser `progn&amp;#39; puisque `let&amp;#39; combine
;; aussi plusieurs sexps.

;; Mettons en forme une chaîne de caractères :
(format &amp;quot;Hello %s!\n&amp;quot; &amp;quot;visitor&amp;quot;)

;; %s désigne l&amp;#39;emplacement de la chaîne, remplacé par &amp;quot;visitor&amp;quot;.
;; \n est le caractère de saut de ligne.

;; Améliorons notre fonction en utilisant &amp;quot;format&amp;quot; :
(defun hello (name)
  (insert (format &amp;quot;Hello %s!\n&amp;quot; name)))

(hello &amp;quot;you&amp;quot;)

;; Créons une autre fonction qui utilise `let&amp;#39; :
(defun greeting (name)
  (let ((your-name &amp;quot;Bastien&amp;quot;))
    (insert (format &amp;quot;Hello %s!\n\nI am %s.&amp;quot;
                    name       ; l&amp;#39;argument de la fonction
                    your-name  ; la variable &amp;quot;let-bindée&amp;quot; &amp;quot;Bastien&amp;quot;
                    ))))

;; Et évaluons-la :
(greeting &amp;quot;you&amp;quot;)

;; Certaines fonctions sont interactives :
(read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)

;; Évaluer cette fonction va renvoyer ce que vous avez saisi dans le
;; minibuffer.

;; Faisons que notre fonction `greeting&amp;#39; vous demande votre nom :
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)))
    (insert (format &amp;quot;Hello!\n\nI am %s and you are %s.&amp;quot;
                    from-name ; l&amp;#39;argument de la fonction
                    your-name ; la variable &amp;quot;let-bindée&amp;quot;, entrée dans le minibuffer
                    ))))

(greeting &amp;quot;Bastien&amp;quot;)

;; Complétons la fonction pour qu&amp;#39;elle affiche le résultat dans
;; l&amp;#39;autre fenêtre :
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer &amp;quot;Enter your name: &amp;quot;)))
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    (insert (format &amp;quot;Hello %s!\n\nI am %s.&amp;quot; your-name from-name))
    (other-window 1)))

;; Maintenant testons :
(greeting &amp;quot;Bastien&amp;quot;)

;; Faites une pause.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Stockons une liste de noms :
(setq list-of-names &amp;#39;(&amp;quot;Sarah&amp;quot; &amp;quot;Chloe&amp;quot; &amp;quot;Mathilde&amp;quot;))

;; Récupérez le premier élément de la liste avec `car&amp;#39; :
(car list-of-names)

;; Récupérez tous les élements sauf le premier avec `cdr&amp;#39; :
(cdr list-of-names)

;; Ajoutez un élément au début avec `push&amp;#39; :
(push &amp;quot;Stephanie&amp;quot; list-of-names)

;; Note : `car&amp;#39; et `cdr&amp;#39; ne modifient pas la liste, mais `push&amp;#39; oui.
;; C&amp;#39;est une différence importante : certaines fonctions n&amp;#39;ont pas
;; d&amp;#39;effets de bord (comme `car&amp;#39;) et d&amp;#39;autres oui (comme `push&amp;#39;).

;; Évaluons `hello&amp;#39; pour tous les éléments dans `list-of-names&amp;#39; :
(mapcar &amp;#39;hello list-of-names)

;; Améliorons `greeting&amp;#39; pour dire hello aux noms de `list-of-names&amp;#39; :
(defun greeting ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    (mapcar &amp;#39;hello list-of-names)
    (other-window 1))

(greeting)

;; Vous vous souvenez de la fonction `hello&amp;#39; définie ci-dessus ?  Elle
;; prend seulement un argument, un nom.  `mapcar&amp;#39; appelle `hello&amp;#39; en
;; utilisant successivement chaque élément de `list-of-names&amp;#39; comme
;; argument de `hello&amp;#39;.

;; Maintenant arrangeons un peu ce qui est affiché dans le buffer :

(defun replace-hello-by-bonjour ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (goto-char (point-min))
    (while (search-forward &amp;quot;Hello&amp;quot;)
      (replace-match &amp;quot;Bonjour&amp;quot;))
    (other-window 1))

;; (goto-char (point-min)) va au début du buffer.
;; (search-forward &amp;quot;Hello&amp;quot;) cherche la chaîne &amp;quot;Hello&amp;quot;.
;; (while x y) évalue la sexp(s) y tant que x renvoie quelque chose.
;; Si x renvoie `nil&amp;#39; (rien), nous sortons de la boucle.

(replace-hello-by-bonjour)

;; Vous devriez voir toutes les occurrences de &amp;quot;Hello&amp;quot; dans le buffer
;; *test* remplacées par &amp;quot;Bonjour&amp;quot;.

;; Vous devriez aussi avoir une erreur : &amp;quot;Search failed: Hello&amp;quot;.
;;
;; Pour éviter cette erreur, il faut dire à `search-forward&amp;#39; si la
;; recherche doit s&amp;#39;arrêter à un certain point du buffer, et si elle
;; doit s&amp;#39;arrêter silencieusement si aucune chaîne n&amp;#39;est trouvée.

;; (search-forward &amp;quot;Hello&amp;quot; nil t) fait ça :

;; L&amp;#39;argument `nil&amp;#39; indique que la recherche n&amp;#39;est pas limitée à une
;; position.  L&amp;#39;argument `t&amp;#39; indique de s&amp;#39;arrêter silencieusement si
;; rien n&amp;#39;est trouvé.

;; Nous utilisons cette sexp dans la fonction ci-dessous, qui ne
;; renvoie pas d&amp;#39;erreur :

(defun hello-to-bonjour ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (erase-buffer)
    ;; Dit hello aux noms de `list-of-names&amp;#39;
    (mapcar &amp;#39;hello list-of-names)
    (goto-char (point-min))
    ;; Remplace &amp;quot;Hello&amp;quot; par &amp;quot;Bonjour&amp;quot;
    (while (search-forward &amp;quot;Hello&amp;quot; nil t)
      (replace-match &amp;quot;Bonjour&amp;quot;))
    (other-window 1))

(hello-to-bonjour)

;; Mettons les noms en gras :

(defun boldify-names ()
    (switch-to-buffer-other-window &amp;quot;*test*&amp;quot;)
    (goto-char (point-min))
    (while (re-search-forward &amp;quot;Bonjour \\(.+\\)!&amp;quot; nil t)
      (add-text-properties (match-beginning 1)
                           (match-end 1)
                           (list &amp;#39;face &amp;#39;bold)))
    (other-window 1))

;; Cette fonction introduit `re-search-forward&amp;#39; : au lieu de chercher
;; la chaîne &amp;quot;Bonjour&amp;quot;, nous cherchons un &amp;quot;pattern&amp;quot; en utilisant une
;; &amp;quot;expression régulière&amp;quot; (le préfixe &amp;quot;re-&amp;quot; signifie &amp;quot;regular
;; expression&amp;quot;).

;; L&amp;#39;expression régulière est &amp;quot;Bonjour \\(.+\\)!&amp;quot; et se lit :
;; la chaîne &amp;quot;Bonjour &amp;quot;, et
;; un groupe de                | c&amp;#39;est la syntaxe \\( ... \\)
;;   n&amp;#39;importe quel caractère  | c&amp;#39;est le .
;;   une ou plusieurs fois     | c&amp;#39;est le +
;; et la chaîne &amp;quot;!&amp;quot;.

;; Prêt ?  Testons !

(boldify-names)

;; `add-text-properties&amp;#39; ajoute des propriétés textuelles telle que
;; des &amp;quot;faces&amp;quot; (une &amp;quot;face&amp;quot; définit la fonte, la couleur, la taille et
;; d&amp;#39;autres propriétés du texte.)

;; Et voilà, c&amp;#39;est fini. Happy hacking!

;; Si vous voulez en savoir plus sur une variable ou une fonction :
;;
;; C-h v une-variable RET
;; C-h f une-fonction RET
;;
;; Pour lire le manuel Emacs Lisp avec Emacs :
;;
;; C-h i m elisp RET
;;
;; Pour lire en ligne une introduction à Emacs Lisp :
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html

;; Merci à ces personnes pour leurs retours et suggetions :
;; - Wes Hardaker
;; - notbob
;; - Kevin Montuori
;; - Arne Babenhauserheide
;; - Alan Schmitt
;; - LinXitoW
;; - Aaron Meurer

&lt;/pre&gt;


</description>
        <pubDate>Thu, 25 Jul 2013 00:00:00 +0200</pubDate>
        <link>https://emacs-doctor.com/apprendre-emacs-lisp-en-15-minutes.html</link>
        <guid isPermaLink="true">https://emacs-doctor.com/apprendre-emacs-lisp-en-15-minutes.html</guid>
        
        
        <category>libre</category>
        
      </item>
    
  </channel>
</rss>
